//! This code was AUTOGENERATED using the kinobi library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun kinobi to update it.
//!
//! [https://github.com/metaplex-foundation/kinobi]
//!

use bytemuck::{Pod, Zeroable};

#[derive(Copy, Clone, Debug, Eq, PartialEq, Pod, Zeroable)]
#[repr(C)]
pub struct CollectionDetails {
    pub size: u64,   // Used for V1
    pub padding: [u8; 8], // Used for V2
    pub variant: u8, // 0 for V1, 1 for V2
    pub _padding: [u8; 7], // Ensure 8-byte alignment
}

impl Default for CollectionDetails {
    fn default() -> Self {
        Self::none()
    }
}

impl CollectionDetails {
    pub const V1: u8 = 0;
    pub const V2: u8 = 1;

    pub fn none() -> Self {
        Self {
            size: 0,
            padding: [0; 8],
            variant: Self::V1,
            _padding: [0; 7],
        }
    }
    
    pub fn new_v1(size: u64) -> Self {
        Self { 
            size, 
            padding: [0; 8],
            variant: Self::V1,
            _padding: [0; 7],
        }
    }
    
    pub fn new_v2(padding: [u8; 8]) -> Self {
        Self { 
            size: 0, 
            padding,
            variant: Self::V2,
            _padding: [0; 7],
        }
    }

    pub fn is_v1(&self) -> bool {
        self.variant == Self::V1
    }
    
    pub fn is_v2(&self) -> bool {
        self.variant == Self::V2
    }
    
    pub fn get_size(&self) -> Option<u64> {
        if self.is_v1() {
            Some(self.size)
        } else {
            None
        }
    }
    
    pub fn get_padding(&self) -> Option<[u8; 8]> {
        if self.is_v2() {
            Some(self.padding)
        } else {
            None
        }
    }
}