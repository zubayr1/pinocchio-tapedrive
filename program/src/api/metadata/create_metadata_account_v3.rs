//! This code was AUTOGENERATED using the kinobi library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun kinobi to update it.
//!
//! [https://github.com/metaplex-foundation/kinobi]
//!

use crate::api::metadata::collection_details::CollectionDetails;
use crate::api::metadata::data_v2::DataV2;
use core::mem::MaybeUninit;
use pinocchio::{
    program,
    pubkey::Pubkey,
    account_info::AccountInfo,
    instruction::{AccountMeta, Instruction, Signer},
    cpi::{slice_invoke, slice_invoke_signed, MAX_CPI_ACCOUNTS},
    program_error::ProgramError,
};
use bytemuck::{Pod, Zeroable};
use crate::state::constant::MPL_TOKEN_METADATA_ID;

/// Accounts.
pub struct CreateMetadataAccountV3 {
    /// Metadata key (pda of ['metadata', program id, mint id])
    pub metadata: Pubkey,
    /// Mint of token asset
    pub mint: Pubkey,
    /// Mint authority
    pub mint_authority: Pubkey,
    /// payer
    pub payer: Pubkey,
    /// update authority info
    pub update_authority: (Pubkey, bool),
    /// System program
    pub system_program: Pubkey,
    /// Rent info
    pub rent_present: u8,
    pub rent: Pubkey,
}

pub struct InstructionOwned {
    pub program_id: Pubkey,
    pub accounts: [AccountMeta<'static>; MAX_CPI_ACCOUNTS],
    pub account_count: u8,
    pub data: [u8; 1 + core::mem::size_of::<CreateMetadataAccountV3InstructionArgs>()],
    pub data_len: u16,
}

impl CreateMetadataAccountV3 {
    pub fn instruction(
        &self,
        args: CreateMetadataAccountV3InstructionArgs,
    ) -> Result<InstructionOwned, ProgramError> {
        self.instruction_with_remaining_accounts(args, &[])
    }
    pub fn instruction_with_remaining_accounts(
        &self,
        args: CreateMetadataAccountV3InstructionArgs,
        remaining_accounts: &[AccountMeta],
    ) -> Result<InstructionOwned, ProgramError> {
        if 7 + remaining_accounts.len() > MAX_CPI_ACCOUNTS {
            return Err(ProgramError::InvalidArgument);
        }
        
        const UNINIT_REF: MaybeUninit<AccountMeta> = MaybeUninit::<AccountMeta>::uninit();
        let mut metas = [UNINIT_REF; MAX_CPI_ACCOUNTS];
        let default_pubkey = Pubkey::default();
        unsafe {
            metas.get_unchecked_mut(0).write(AccountMeta::new(&self.metadata, true, false));
            metas.get_unchecked_mut(1).write(AccountMeta::readonly(&self.mint));
            metas.get_unchecked_mut(2).write(AccountMeta::readonly(&self.mint_authority));
            metas.get_unchecked_mut(3).write(AccountMeta::new(&self.payer, true, true));
            metas.get_unchecked_mut(4).write(AccountMeta::new(&self.update_authority.0, true, self.update_authority.1));
            metas.get_unchecked_mut(5).write(AccountMeta::readonly(&self.system_program));
            if self.rent_present == 1 {
                metas.get_unchecked_mut(6).write(AccountMeta::readonly(&self.rent));
            } else {                
                metas.get_unchecked_mut(6).write(AccountMeta::readonly(&default_pubkey));
            }
        }

        for i in 0..remaining_accounts.len() {
            unsafe {
                metas
                    .get_unchecked_mut(i + 7)
                    .write(remaining_accounts.get_unchecked(i).clone());
            }
        }
        
        let account_count = 7 + remaining_accounts.len();        
       
        let mut data = [0u8; 1 + core::mem::size_of::<CreateMetadataAccountV3InstructionArgs>()];
        data[0] = CreateMetadataAccountV3InstructionData::get_discriminator(); // discriminator
        
        let args_bytes = bytemuck::bytes_of(&args);
        data[1..1 + args_bytes.len()].copy_from_slice(args_bytes);        

        Ok(InstructionOwned {
            program_id: MPL_TOKEN_METADATA_ID,
            accounts: unsafe { core::mem::transmute(metas) },
            account_count: account_count as u8,
            data,
            data_len: data.len() as u16,
        })
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Pod, Zeroable)]
#[repr(C)]
struct CreateMetadataAccountV3InstructionData {
    discriminator: u8,
}

impl CreateMetadataAccountV3InstructionData {
    fn get_discriminator() -> u8 {
        33
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Pod, Zeroable)]
#[repr(C)]
pub struct CreateMetadataAccountV3InstructionArgs {    
    pub data: DataV2,
    pub collection_details: CollectionDetails,
    pub is_mutable: u8,
    pub collection_details_present: u8,
    pub _padding: [u8; 6],
}

/// Instruction builder for `CreateMetadataAccountV3`.
///
/// ### Accounts:
///
///   0. `[writable]` metadata
///   1. `[]` mint
///   2. `[signer]` mint_authority
///   3. `[writable, signer]` payer
///   4. `[signer]` update_authority
///   5. `[optional]` system_program (default to `11111111111111111111111111111111`)
///   6. `[optional]` rent

#[derive(Debug)]
pub struct CreateMetadataAccountV3Builder<'b> {
    metadata_present: u8,
    metadata: Pubkey,
    mint_present: u8,
    mint: Pubkey,
    mint_authority: Pubkey,
    payer_present: u8,
    payer: Pubkey,
    update_authority_present: u8,
    update_authority: (Pubkey, bool),
    system_program: Pubkey,
    rent_present: u8,
    rent: Pubkey,
    data_present: u8,
    data: DataV2,
    is_mutable_present: u8,
    is_mutable: u8,
    collection_details_present: u8,
    collection_details: CollectionDetails,
    __remaining_accounts: [MaybeUninit<AccountMeta<'b>>; MAX_CPI_ACCOUNTS],
    __remaining_accounts_len: u16,
}

impl<'b> CreateMetadataAccountV3Builder<'b> {
    pub fn new() -> Self {
        Self {
            metadata_present: 0,
            metadata: Pubkey::default(),
            mint_present: 0,
            mint: Pubkey::default(),
            mint_authority: Pubkey::default(),
            payer_present: 0,
            payer: Pubkey::default(),
            update_authority_present: 0,
            update_authority: (Pubkey::default(), false),
            system_program: Pubkey::default(),
            rent_present: 0,
            rent: Pubkey::default(),
            data_present: 0,
            data: DataV2::default(),
            is_mutable_present: 0,
            is_mutable: 0,
            collection_details_present: 0,
            collection_details: CollectionDetails::default(),
            __remaining_accounts: unsafe { MaybeUninit::uninit().assume_init() },
            __remaining_accounts_len: 0,
        }
    }
    /// Metadata key (pda of ['metadata', program id, mint id])
    #[inline(always)]
    pub fn metadata(&mut self, metadata: Pubkey) -> &mut Self {
        self.metadata_present = 1;
        self.metadata = metadata;
        self
    }
    /// Mint of token asset
    #[inline(always)]
    pub fn mint(&mut self, mint: Pubkey) -> &mut Self {
        self.mint_present = 1;
        self.mint = mint;
        self
    }
    /// Mint authority
    #[inline(always)]
    pub fn mint_authority(&mut self, mint_authority: Pubkey) -> &mut Self {
        self.mint_present = 1;
        self.mint_authority = mint_authority;
        self
    }
    /// payer
    #[inline(always)]
    pub fn payer(&mut self, payer: Pubkey) -> &mut Self {
        self.payer_present = 1;
        self.payer = payer;
        self
    }
    /// update authority info
    #[inline(always)]
    pub fn update_authority(
        &mut self,
        update_authority: Pubkey,
        as_signer: bool,
    ) -> &mut Self {
        self.update_authority_present = 1;
        self.update_authority = (update_authority, as_signer);
        self
    }
//     /// `[optional account, default to '11111111111111111111111111111111']`
//     /// System program
//     #[inline(always)]
//     pub fn system_program(&mut self, system_program: Pubkey) -> &mut Self {
//         self.system_program = Some(system_program);
//         self
//     }
    /// `[optional account]`
    /// Rent info
    #[inline(always)]
    pub fn rent(&mut self, rent: Pubkey) -> &mut Self {
        self.rent_present = 1;
        self.rent = rent;
        self
    }
    #[inline(always)]
    pub fn data(&mut self, data: DataV2) -> &mut Self {
        self.data_present = 1;
        self.data = data;
        self
    }
    #[inline(always)]
    pub fn is_mutable(&mut self, is_mutable: u8) -> &mut Self {
        self.is_mutable_present = 1;
        self.is_mutable = is_mutable;
        self
    }
    /// `[optional argument]`
    #[inline(always)]
    pub fn collection_details(&mut self, collection_details: CollectionDetails) -> &mut Self {
        self.collection_details_present = 1;
        self.collection_details = collection_details;
        self
    }
    /// Add an aditional account to the instruction.
    #[inline(always)]
    pub fn add_remaining_account(
        &mut self,
        account: AccountMeta<'b>,
    ) -> &mut Self {
        self.__remaining_accounts[self.__remaining_accounts_len as usize].write(account);
        self.__remaining_accounts_len += 1;
        self
    }
    /// Add additional accounts to the instruction.
    #[inline(always)]
    pub fn add_remaining_accounts(
        &mut self,
        accounts: &[AccountMeta<'b>],
    ) -> &mut Self {
        for account in accounts {
            let len = self.__remaining_accounts_len as usize;

            if len < MAX_CPI_ACCOUNTS {
                self.__remaining_accounts[len].write(account.clone());
                self.__remaining_accounts_len += 1;
            }
        }
        self
    }
    // #[allow(clippy::clone_on_copy)]
    pub fn instruction(&self) -> Result<Instruction, ProgramError> {
        let accounts = CreateMetadataAccountV3 {
            metadata: self.metadata,
            mint: self.mint,
            mint_authority: self.mint_authority,
            payer: self.payer,
            update_authority: self.update_authority,
            system_program: self.system_program,
            rent_present: self.rent_present,
            rent: self.rent,
        };
        let args = CreateMetadataAccountV3InstructionArgs {
            data: self.data,
            is_mutable: self.is_mutable,
            collection_details: self.collection_details,
            collection_details_present: self.collection_details_present,
            _padding: [0u8; 6],
        };

        let instruction = accounts.instruction_with_remaining_accounts(args, &[])?;

        let metas_slice: &[AccountMeta] = unsafe {
            core::slice::from_raw_parts(instruction.accounts.as_ptr() as *const AccountMeta, instruction.account_count as usize)
        };

        let data_slice = unsafe {
            core::slice::from_raw_parts(instruction.data.as_ptr() as *const u8, instruction.data.len())
        };

        Ok(Instruction {
            program_id: &MPL_TOKEN_METADATA_ID,
            accounts: metas_slice,
            data: data_slice,
        })
    }
}

/// `create_metadata_account_v3` CPI accounts.
pub struct CreateMetadataAccountV3CpiAccounts<'b> {
    /// Metadata key (pda of ['metadata', program id, mint id])
    pub metadata: &'b AccountInfo,
    /// Mint of token asset
    pub mint: &'b AccountInfo,
    /// Mint authority
    pub mint_authority: &'b AccountInfo,
    /// payer
    pub payer: &'b AccountInfo,
    /// update authority info
    pub update_authority: (&'b AccountInfo, bool),
    /// System program
    pub system_program: &'b AccountInfo,
    /// Rent info
    pub rent_present: u8,
    pub rent: &'b AccountInfo,
}

/// `create_metadata_account_v3` CPI instruction.
pub struct CreateMetadataAccountV3Cpi<'b> {
    /// The program to invoke.
    pub __program: &'b AccountInfo,
    /// Metadata key (pda of ['metadata', program id, mint id])
    pub metadata: &'b AccountInfo,
    /// Mint of token asset
    pub mint: &'b AccountInfo,
    /// Mint authority
    pub mint_authority: &'b AccountInfo,
    /// payer
    pub payer: &'b AccountInfo,
    /// update authority info
    pub update_authority: (&'b AccountInfo, bool),
    /// System program
    pub system_program: &'b AccountInfo,
    /// Rent info
    pub rent_present: u8,
    pub rent: &'b AccountInfo,
    /// The arguments for the instruction.
    pub __args: CreateMetadataAccountV3InstructionArgs,
}

impl<'b> CreateMetadataAccountV3Cpi<'b> {
    pub fn new(
        program: &'b AccountInfo,
        accounts: CreateMetadataAccountV3CpiAccounts<'b>,
        args: CreateMetadataAccountV3InstructionArgs,
    ) -> Self {
        Self {
            __program: program,
            metadata: accounts.metadata,
            mint: accounts.mint,
            mint_authority: accounts.mint_authority,
            payer: accounts.payer,
            update_authority: accounts.update_authority,
            system_program: accounts.system_program,
            rent_present: accounts.rent_present,
            rent: accounts.rent,
            __args: args,
        }
    }
    #[inline(always)]
    pub fn invoke(&self) -> Result<(), ProgramError> {
        self.invoke_signed_with_remaining_accounts(&[], &[])
    }
    #[inline(always)]
    pub fn invoke_with_remaining_accounts(
        &self,
        remaining_accounts: &[(
            &'b AccountInfo,
            bool,
            bool,
        )],
    ) -> Result<(), ProgramError> {
        self.invoke_signed_with_remaining_accounts(&[], remaining_accounts)
    }
    #[inline(always)]
    pub fn invoke_signed(
        &self,
        signers_seeds: &[Signer],
    ) -> Result<(), ProgramError> {
        self.invoke_signed_with_remaining_accounts(signers_seeds, &[])
    }
    // #[allow(clippy::clone_on_copy)]
    // #[allow(clippy::vec_init_then_push)]
    pub fn invoke_signed_with_remaining_accounts(
        &self,
        signers_seeds: &[Signer],
        remaining_accounts: &[(
            &'b AccountInfo,
            bool,
            bool,
        )],
    ) -> Result<(), ProgramError> {
        if 7 + remaining_accounts.len() > MAX_CPI_ACCOUNTS {
            return Err(ProgramError::InvalidArgument);
        }

        const UNINIT_REF: MaybeUninit<AccountMeta> = MaybeUninit::<AccountMeta>::uninit();
        let mut metas = [UNINIT_REF; MAX_CPI_ACCOUNTS];

        let default_pubkey = Pubkey::default();
        unsafe {
            metas.get_unchecked_mut(0).write(AccountMeta::new(self.metadata.key(), false, false));
            metas.get_unchecked_mut(1).write(AccountMeta::readonly(self.mint.key()));
            metas.get_unchecked_mut(2).write(AccountMeta::readonly(self.mint_authority.key()));
            metas.get_unchecked_mut(3).write(AccountMeta::new(self.payer.key(), true, true));
            metas.get_unchecked_mut(4).write(AccountMeta::new(self.update_authority.0.key(), true, self.update_authority.1));
            metas.get_unchecked_mut(5).write(AccountMeta::readonly(self.system_program.key()));
            if self.rent_present == 1 {
                metas.get_unchecked_mut(6).write(AccountMeta::readonly(self.rent.key()));
            } else {                
                metas.get_unchecked_mut(6).write(AccountMeta::readonly(&default_pubkey));
            }
        }
        
        for i in 0..remaining_accounts.len() {
            unsafe {
                metas
                    .get_unchecked_mut(i + 7)
                    .write(AccountMeta {
                        pubkey: remaining_accounts.get_unchecked(i).0.key(),
                        is_signer: remaining_accounts.get_unchecked(i).1,
                        is_writable: remaining_accounts.get_unchecked(i).2,
                    });
            }
        }

        let mut data = [0u8; 1 + core::mem::size_of::<CreateMetadataAccountV3InstructionArgs>()];
        data[0] = CreateMetadataAccountV3InstructionData::get_discriminator(); // discriminator
        
        let args_bytes = bytemuck::bytes_of(&self.__args);
        data[1..1 + args_bytes.len()].copy_from_slice(args_bytes);

        let account_count = 7 + remaining_accounts.len();

        let metas_slice: &[AccountMeta] = unsafe {
            core::slice::from_raw_parts(metas.as_ptr() as *const AccountMeta, account_count)
        };

        let data_slice = unsafe {
            core::slice::from_raw_parts(data.as_ptr() as *const u8, data.len())
        };

        let instruction = Instruction {
            program_id: &MPL_TOKEN_METADATA_ID,
            accounts: metas_slice,
            data: data_slice,
        };

        const UNINIT_INF: MaybeUninit<AccountInfo> = MaybeUninit::<AccountInfo>::uninit();
        let mut account_infos = [UNINIT_INF; MAX_CPI_ACCOUNTS];

        unsafe {
            account_infos.get_unchecked_mut(0).write(self.__program.clone());
            account_infos.get_unchecked_mut(1).write(self.metadata.clone());
            account_infos.get_unchecked_mut(2).write(self.mint.clone());
            account_infos.get_unchecked_mut(3).write(self.mint_authority.clone());
            account_infos.get_unchecked_mut(4).write(self.payer.clone());
            account_infos.get_unchecked_mut(5).write(self.update_authority.0.clone());
            account_infos.get_unchecked_mut(6).write(self.system_program.clone());
            if self.rent_present == 1 {
                account_infos.get_unchecked_mut(7).write(self.rent.clone());
            } else {
                account_infos.get_unchecked_mut(7).write(self.system_program.clone());
            }
        }

        let account_count = 7 + remaining_accounts.len();

        let account_infos_slice: &[AccountInfo] = unsafe {
            core::slice::from_raw_parts(account_infos.as_ptr() as *const AccountInfo, account_count)
        };

        let mut account_infos_refs: [MaybeUninit<&AccountInfo>; MAX_CPI_ACCOUNTS] =
        unsafe { MaybeUninit::uninit().assume_init() };

        for i in 0..account_count {
            account_infos_refs[i].write(&account_infos_slice[i]);
        }

        let final_slice_for_invoke = unsafe {
            core::slice::from_raw_parts(
                account_infos_refs.as_ptr() as *const &AccountInfo,
                account_count,
            )
        };

        if signers_seeds.is_empty() {
            slice_invoke(&instruction, &final_slice_for_invoke)
        } else {
            slice_invoke_signed(&instruction, &final_slice_for_invoke, signers_seeds)
        }
    }
}

/// Instruction builder for `CreateMetadataAccountV3` via CPI.
///
/// ### Accounts:
///
///   0. `[writable]` metadata
///   1. `[]` mint
///   2. `[signer]` mint_authority
///   3. `[writable, signer]` payer
///   4. `[signer]` update_authority
///   5. `[]` system_program
///   6. `[optional]` rent
pub struct CreateMetadataAccountV3CpiBuilder<'b> {
    instruction: CreateMetadataAccountV3CpiBuilderInstruction<'b>,
}

impl<'b> CreateMetadataAccountV3CpiBuilder<'b> {
    pub fn new(program: &'b AccountInfo) -> Self {
        let instruction = CreateMetadataAccountV3CpiBuilderInstruction {
            __program: program,
            metadata_present: 0,
            metadata: program,
            mint_present: 0,
            mint: program,
            mint_authority: program,
            payer_present: 0,
            payer: program,
            update_authority_present: 0,
            update_authority: (program, false),
            system_program: program,
            rent_present: 0,
            rent: program,
            data_present: 0,
            data: DataV2::default(),
            is_mutable_present: 0,
            is_mutable: 0,
            collection_details_present: 0,
            collection_details: CollectionDetails::default(),
            __remaining_accounts: unsafe { MaybeUninit::uninit().assume_init() },
            __remaining_accounts_len: 0,
        };
        Self { instruction }
    }
    /// Metadata key (pda of ['metadata', program id, mint id])
    #[inline(always)]
    pub fn metadata(
        &mut self,
        metadata: &'b AccountInfo,
    ) -> &mut Self {
        self.instruction.metadata_present = 1;
        self.instruction.metadata = metadata;
        self
    }
    /// Mint of token asset
    #[inline(always)]
    pub fn mint(&mut self, mint: &'b AccountInfo) -> &mut Self {
        self.instruction.mint_present = 1;
        self.instruction.mint = mint;
        self
    }
    /// Mint authority
    #[inline(always)]
    pub fn mint_authority(
        &mut self,
        mint_authority: &'b AccountInfo,
    ) -> &mut Self {
        self.instruction.mint_present = 1;
        self.instruction.mint_authority = mint_authority;
        self
    }
    /// payer
    #[inline(always)]
    pub fn payer(&mut self, payer: &'b AccountInfo) -> &mut Self {
        self.instruction.payer_present = 1;
        self.instruction.payer = payer;
        self
    }
    /// update authority info
    #[inline(always)]
    pub fn update_authority(
        &mut self,
        update_authority: &'b AccountInfo,
        as_signer: bool,
    ) -> &mut Self {
        self.instruction.update_authority_present = 1;
        self.instruction.update_authority = (update_authority, as_signer);
        self
    }
    // /// System program
    // #[inline(always)]
    // pub fn system_program(
    //     &mut self,
    //     system_program: &'b AccountInfo<'a>,
    // ) -> &mut Self {
    //     self.instruction.system_program = Some(system_program);
    //     self
    // }
    /// `[optional account]`
    /// Rent info
    #[inline(always)]
    pub fn rent(
        &mut self,
        rent: &'b AccountInfo,
    ) -> &mut Self {
        self.instruction.rent_present = 1;
        self.instruction.rent = rent;
        self
    }
    #[inline(always)]
    pub fn data(&mut self, data: DataV2) -> &mut Self {
        self.instruction.data_present = 1;
        self.instruction.data = data;
        self
    }
    #[inline(always)]
    pub fn is_mutable(&mut self, is_mutable: u8) -> &mut Self {
        self.instruction.is_mutable_present = 1;
        self.instruction.is_mutable = is_mutable;
        self
    }
    /// `[optional argument]`
    #[inline(always)]
    pub fn collection_details(&mut self, collection_details: CollectionDetails) -> &mut Self {
        self.instruction.collection_details_present = 1;
        self.instruction.collection_details = collection_details;
        self
    }
    /// Add an additional account to the instruction.
    #[inline(always)]
    pub fn add_remaining_account(
        &mut self,
        account: &'b AccountInfo,
        is_writable: bool,
        is_signer: bool,
    ) -> &mut Self {
        self.instruction.__remaining_accounts[self.instruction.__remaining_accounts_len as usize] = 
            MaybeUninit::new((account, is_writable, is_signer));
        self.instruction.__remaining_accounts_len += 1;
        self
    }
    /// Add additional accounts to the instruction.
    ///
    /// Each account is represented by a tuple of the `AccountInfo`, a `bool` indicating whether the account is writable or not,
    /// and a `bool` indicating whether the account is a signer or not.
    #[inline(always)]
    pub fn add_remaining_accounts(
        &mut self,
        accounts: &[(
            &'b AccountInfo,
            bool,
            bool,
        )],
    ) -> &mut Self {
        for i in 0..accounts.len() {
            self.instruction.__remaining_accounts[i] = 
                MaybeUninit::new((accounts[i].0, accounts[i].1, accounts[i].2));
        }
        self.instruction.__remaining_accounts_len += accounts.len() as u16;
        self
    }
    #[inline(always)]
    pub fn invoke(&self) -> Result<(), ProgramError> {
        self.invoke_signed(&[])
    }
    #[allow(clippy::clone_on_copy)]
    #[allow(clippy::vec_init_then_push)]
    pub fn invoke_signed(
        &self,
        signers_seeds: &[Signer],
    ) -> Result<(), ProgramError> {
        assert!(self.instruction.data_present == 1, "data is not set");
        assert!(self.instruction.is_mutable_present == 1, "is_mutable is not set");
        assert!(self.instruction.collection_details_present == 1, "collection_details is not set");

        let args = CreateMetadataAccountV3InstructionArgs {
            data: self.instruction.data.clone(),
            is_mutable: self
                .instruction
                .is_mutable
                .clone(),
            collection_details: self.instruction.collection_details.clone(),
            _padding: [0u8; 6],
            collection_details_present: self.instruction.collection_details_present,
        };
        assert!(self.instruction.metadata_present == 1, "metadata is not set");
        assert!(self.instruction.mint_present == 1, "mint is not set");
        assert!(self.instruction.payer_present == 1, "payer is not set");
        assert!(self.instruction.update_authority_present == 1, "update_authority is not set");
        assert!(self.instruction.rent_present == 1, "rent is not set");        

        let instruction = CreateMetadataAccountV3Cpi {
            __program: self.instruction.__program,

            metadata: self.instruction.metadata,

            mint: self.instruction.mint,

            mint_authority: self
                .instruction
                .mint_authority,

            payer: self.instruction.payer,

            update_authority: self
                .instruction
                .update_authority,

            system_program: self
                .instruction
                .system_program,

            rent_present: self.instruction.rent_present,
            rent: self.instruction.rent,
            __args: args,
        };

        let remaining_accounts_slice: &[(&AccountInfo, bool, bool)] = unsafe {
            core::slice::from_raw_parts(
                self.instruction.__remaining_accounts.as_ptr() as *const (&AccountInfo, bool, bool),
                self.instruction.__remaining_accounts_len as usize,
            )
        };
        
        instruction.invoke_signed_with_remaining_accounts(
            signers_seeds,
            remaining_accounts_slice,
        )
    }
}

struct CreateMetadataAccountV3CpiBuilderInstruction<'b> {
    __program: &'b AccountInfo,
    metadata_present: u8,
    metadata: &'b AccountInfo,
    mint_present: u8,
    mint: &'b AccountInfo,
    mint_authority: &'b AccountInfo,
    payer_present: u8,
    payer: &'b AccountInfo,
    update_authority_present: u8,
    update_authority: (&'b AccountInfo, bool),
    system_program: &'b AccountInfo,
    rent_present: u8,
    rent: &'b AccountInfo,
    data_present: u8,
    data: DataV2,
    is_mutable_present: u8,
    is_mutable: u8,
    collection_details_present: u8,
    collection_details: CollectionDetails,
    /// Additional instruction accounts `(AccountInfo, is_writable, is_signer)`.
    __remaining_accounts: [MaybeUninit<(
        &'b AccountInfo,
        bool,
        bool,
    )>; MAX_CPI_ACCOUNTS],
    __remaining_accounts_len: u16,
}