use crate::api::consts::*;
use pinocchio::pubkey::{Pubkey, find_program_address};
use pinocchio_associated_token_account;

#[cfg(debug_assertions)]
pub fn archive_pda() -> (Pubkey, u8) {
    find_program_address(&[ARCHIVE], &crate::id())
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn archive_pda() -> (Pubkey, u8) {
    (ARCHIVE_ADDRESS.into(), ARCHIVE_BUMP)
}

#[cfg(debug_assertions)]
pub fn epoch_pda() -> (Pubkey, u8) {
    find_program_address(&[EPOCH], &crate::id())
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn epoch_pda() -> (Pubkey, u8) {
    (EPOCH_ADDRESS.into(), EPOCH_BUMP)
}

#[cfg(debug_assertions)]
pub fn block_pda() -> (Pubkey, u8) {
    find_program_address(&[BLOCK], &crate::id())
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn block_pda() -> (Pubkey, u8) {
    (BLOCK_ADDRESS.into(), BLOCK_BUMP)
}

#[cfg(debug_assertions)]
pub fn treasury_pda() -> (Pubkey, u8) {
    find_program_address(&[TREASURY], &crate::id())
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn treasury_pda() -> (Pubkey, u8) {
    (TREASURY_ADDRESS.into(), TREASURY_BUMP)
}

#[cfg(debug_assertions)]
pub fn treasury_ata() -> (Pubkey, u8) {
    let (treasury_pda, _bump) = treasury_pda();
    let (mint_pda, _bump) = mint_pda();
    find_program_address(
        &[
            treasury_pda.as_ref(),
            spl_token::ID.as_ref(),
            mint_pda.as_ref(),
        ],
        &spl_associated_token_account::ID,
    )
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn treasury_ata() -> (Pubkey, u8) {
    (TREASURY_ATA.into(), TREASURY_ATA_BUMP)
}

#[cfg(debug_assertions)]
pub fn mint_pda() -> (Pubkey, u8) {
    find_program_address(&[MINT, MINT_SEED], &crate::id())
}

#[cfg(not(debug_assertions))]
#[inline(always)]
pub fn mint_pda() -> (Pubkey, u8) {
    (MINT_ADDRESS.into(), MINT_BUMP)
}

pub fn metadata_pda(mint: Pubkey) -> (Pubkey, u8) {
    find_program_address(
        &[METADATA, MPL_TOKEN_METADATA_ID.as_ref(), mint.as_ref()],
        &MPL_TOKEN_METADATA_ID,
    )
}

pub fn tape_pda(authority: Pubkey, name: &[u8; NAME_LEN]) -> (Pubkey, u8) {
    find_program_address(&[TAPE, authority.as_ref(), name.as_ref()], &crate::id())
}

pub fn writer_pda(tape: Pubkey) -> (Pubkey, u8) {
    find_program_address(&[WRITER, tape.as_ref()], &crate::id())
}

pub fn miner_pda(authority: Pubkey, name: [u8; NAME_LEN]) -> (Pubkey, u8) {
    find_program_address(&[MINER, authority.as_ref(), name.as_ref()], &crate::id())
}

pub fn spool_pda(miner: Pubkey, number: u64) -> (Pubkey, u8) {
    find_program_address(
        &[SPOOL, miner.as_ref(), number.to_le_bytes().as_ref()],
        &crate::id(),
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pda_against_consts() {
        // These tests, as nonsensical as they seem, are to ensure that the PDAs generated by the
        // consts match the ones generated by the official functions. The consts are generated by
        // external deps, so if we straight up use the consts, we are trusting that the external
        // deps are working as expected, which is not a good idea. Always be testing.

        let (pda, bump) = archive_pda();
        assert_eq!(bump, ARCHIVE_BUMP);
        assert_eq!(pda, ARCHIVE_ADDRESS);

        let (pda, bump) = epoch_pda();
        assert_eq!(bump, EPOCH_BUMP);
        assert_eq!(pda, EPOCH_ADDRESS);

        let (pda, bump) = block_pda();
        assert_eq!(bump, BLOCK_BUMP);
        assert_eq!(pda, BLOCK_ADDRESS);

        let (pda, bump) = mint_pda();
        assert_eq!(bump, MINT_BUMP);
        assert_eq!(pda, MINT_ADDRESS);

        let (pda, bump) = treasury_pda();
        assert_eq!(bump, TREASURY_BUMP);
        assert_eq!(pda, TREASURY_ADDRESS);

        let (pda, _bump) = treasury_ata();
        assert_eq!(pda, TREASURY_ATA);
    }
}
